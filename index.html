<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<meta name="description" content="An introduction to geospatial computing using Rust" />
        <meta name="author" content="Stephan H√ºgel" />
		<title>Coordinate System</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/solarized-dark.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- <section>Slide 1</section> -->
				<!-- <section>Slide 2</section> -->
				<section data-markdown>
			    <script type="text/template">
				        ## Teaching Myself Rust via the medium of Coordinate System Transforms
				        Stephan H√ºgel, UCL CASA
				    </script>
				</section>
				<section data-markdown>
			    <script type="text/template">
				        ## About Me
				        - 4th year PhD student (I should be writing)
				        	- English degree
				        	- Master's in DH
				        - I mostly work on smart cities ‚Äì history, policy, future
				        - Programming is not my job
					        - I do data analysis and visualisation as productive procrastination
					        - Mostly work in Python (Pandas, NumPy, Matplotlib, Basemap)
					        - I use a lot of maps of parts of the UK
				</script>
				</section>
				<!-- vertical example slides -->
				<section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
					## Data Analysis
					[![Routing](https://github.com/urschrei/router_comparison/raw/master/combined_gh.png)]()
					</script>
					</section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
					## Spatial Analysis
					[![Gridding](https://github.com/urschrei/Geopython/raw/master/data/rainfall_interpolation.gif)]()
					</script>
					</section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
					## Data Viz
					[![Transforms](assets/isochrone.png)]()
					</script>
					</section>
					<section data-background-video="assets/tweetcity.mp4" data-background-video-loop data-background-video-muted>
					<script type="text/template">
					</script>
					</section>
				</section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
I'd give this talk in German, but you might say it's a little‚Ä¶<!-- .element: class="fragment" data-fragment-index="1" -->

Rusty.  <!-- .element: class="fragment" data-fragment-index="2" -->

üòé <!-- .element: class="fragment" data-fragment-index="3" -->
					</script>
					</section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
(I'm so, so sorry)
					</script>
					</section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
					### Why Rust?
					- A series of weird coincidences
					- A need to convert large numbers of coordinates
						- Ordinarily, you'd use PROJ.4 for this
					</script>
					</section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
					### PROJ.4
					- General library for coordinate transformations
					- Has a long, FORTRAN-based heritage (going back to the 80s)
					- First PROJ.4 release was 1994
					- High-quality, well-maintained, open-source
					- `Pyproj` is a Cython-based wrapper for PROJ.4
					</script>
					</section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
				    I wanted to see whether I could write something as fast, and as correct as PROJ.4
					</script>
					</section>
				<section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
				    ## A Brief Discussion of Coordinate Reference Systems
					</script>
					</section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ### What is a coordinate (reference) system (CRS)
					        - A way of describing locations on earth
					        - Two components: the *datum*, and the *coordinate system*

					        - **Datum**: describes how the CRS is related to the earth
					        	- Position of the origin
					        	- Scale
					        	- **Surface**
					        	- **Geoid**

					        - **Coordinate system**: describes how the coordinates are expressed
					        	- Cartesian (x, y, z)
					        	- Ellipsoidal ($\lambda, \mu, \nu$)
					        	- Projected coordinates (UTM: 13.38891¬∫ E, 52.51690¬∫ N)
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ### WGS 84 
					        - US-led, but now a global system
					        - Datum specifies an origin at the centre of the earth
					        - Uses the WGS 84 ellipsoid
					        - Position within WGS 84 is determined using GPS
					        - Designed to be globally consistent ¬±1m
					        - ETRS89 is a high-accuracy "realisation" of WGS 84, used for surveying in Europe
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
					Of course, the UK has no interest in these fripperies
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
### The "National Grid"
- Used on UK maps
- Also used in Shape Files
- Based on OSGB36 datum
- Uses an ellipsoid known as **Airy 1830** üí®
	- (It's actually named after Sir George Biddell Airy KCB PRS)
    - It's a better fit for Britain than WGS 84, because it fits the local sea level more accurately üåä
- On maps, it uses Easting and Northing coordinates
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
## Transforming Between Coordinate Systems
### The Helmert Transform
Datums can differ in three ways:

1. Position of the origin of coordinates
2. Orientation of the coordinate axes (and hence of the reference ellipsoid)
3. Size and shape of the reference ellipsoid
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
## Transforming Between Coordinate Systems, II
- If you work in 3D cartesian coordinates, you don't have to worry about (3)
- It's straightforward to carry out this conversion
- Just trust me on this
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
## Transforming Between Coordinate Systems, III
We use six parameters to describe the difference between two datums:
- Three parameters to describe a 3D translation between the coordinate origins
- Three parameters to describe a 3D rotation between the orientations of the coordinate axes.

This can be expressed as a linear formula which assumes that the rotation parameters are ‚Äòsmall‚Äô
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
## omgmatrices
$
\begin{bmatrix}
    x\\\
    y\\\
    z\\\
\end{bmatrix}^B
=
\begin{bmatrix}
    t_X\\\
    t_Y\\\
    t_Z\\\
\end{bmatrix}
+
\begin{bmatrix}
    1+s  & -r_Z & r_Y\\\
    r_Z  & 1+s  & -r_X\\\
    -r_Y & r_X  & 1+s\\\
\end{bmatrix}
\cdot
\begin{bmatrix}
    x\\\
    y\\\
    z\\\
\end{bmatrix}^A
$
Where:
- $t_X$ ,$t_Y$ and $t_Z$ are the translations along the X, Y and Z axes respectively in metres,
- $r_X$ , $r_Y$ and $r_Z$ are the rotations about the X, Y and Z axes respectively in radians
- $s$ is the scale factor (unitless) minus one.

(there are no more mathematical formul√¶ in this talk, fyi)
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ### So we're done here?
					        Well, no.
					        ‚Ä¶the Helmert transform introduces horizontal error up to 3m.  
					        (we're not really worried about height)  

					        This is OK, but no use for accurate applications like surveying.
					        These demand transformations accurate to around 0.1m
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
### Thankfully, UK Ordnance Survey Has Got This
#### The OSTN02‚Ñ¢ and OSTN15‚Ñ¢ transforms
- "Rubber-sheet" transforms
- Use a file of grid shift parameters with 1km resolution
- Bilinear interpolation to get precise adjustments
- OSTN15 is the latest version, it launched about a week ago 
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
						### Implementing the OSTN02‚Ñ¢ / OSTN15‚Ñ¢ transform

						1. Carry out Helmert Transform
							- (WGS84 Lon, Lat ‚û°Ô∏è ETRS89 Eastings and Northings)
							- This introduces some positional error into the coordinate
						2. Retrieve grid shift parameters for the relevant kilometer grid
						3. Bilinear interpolation to determine precise corrections to apply
						4. Addition of these produces the shift from the GRS80 to the Airy 1830 Ellipsoid
						5. We're pretty much done
				    </script>
				    </section>
			    </section>
			    <section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
				        ### Getting Started
				        - I have no idea how FFI works in Rust
				        - I asked on SO, outlining my (terrible, btw) design
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
### FFI
```rust
#[repr(C)]
pub struct Array {
    data: *const c_void,
    len: libc::size_t,
}

impl Array {
    unsafe fn as_f32_slice(&self) -> &[f32] {
        assert!(!self.data.is_null());
        slice::from_raw_parts(self.data as *const f32, self.len as usize)
    }
    unsafe fn as_i32_slice(&self) -> &[i32] {
        assert!(!self.data.is_null());
        slice::from_raw_parts(self.data as *const i32, self.len as usize)
    }

    fn from_vec<T>(mut vec: Vec<T>) -> Array {
        // Important to make length and capacity match
        // A better solution is to track both length and capacity
        vec.shrink_to_fit();
        let array = Array {
            data: vec.as_ptr() as *const libc::c_void,
            len: vec.len() as libc::size_t
        };
        // Whee! Leak the memory, and now the raw pointer (and
        // eventually C) is the owner.
        mem::forget(vec);
        array
    }
}

#[no_mangle]
pub extern fn drop_array(p: *const Array) {
    if p.is_null() { return }
    unsafe { drop(p) };
}
```
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
				        ### Implementing the transform
				        - This was‚Ä¶really easy?
				        - Almost nothing Rust-specific
				        	1. A series of arithmetic and trig operations
				        	2. Lookup and addition of adjustments
				        
				        `conversions.rs`, L284‚Äì373
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
				        ### Checking for floating-point instability
				        Use Herbie!
				        - Developed as a standalone tool by UW
				        - Implemented as a compiler plugin, so you'll need Nightly
				        - It doesn't just find problems, it suggests improvements!

				        https://github.com/mcarton/rust-herbie-lint
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
### Integrating the adjustments
There's just one problem: there are 876,951 adjustments.  
Each adjustment is a set of three floating-point values.  
They're in a SQLite DB  
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
### PHF
- A compile-time static map
- Copy and adapt the `PHF` example
	- Get all the records using `rusqlite`
	- Key is an `i32`, value is `(f64, f64, f64)`
- It takes a long time to build
- It also takes a long time to compile
	- Split it into a separate crate, add it to `Cargo.toml`
	- Never worry about it again
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
				        ## I Want This To Be Fast 
				    </script>
				    </section>

				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
### First Attempt at Threading
```rust
#[no_mangle]
pub extern "C" fn convert_thr(eastings: Array, northings: Array) -> Array {
    let lon = unsafe { eastings.as_i32_slice() };
    let lat = unsafe { northings.as_i32_slice() };
    // copy values and combine
    let orig: Vec<(i32, i32)> = lon.iter()
        .cloned()
        .zip(lat.iter()
            .cloned())
        .collect();
    let mut guards: Vec<JoinHandle<Vec<(f64, f64)>>> = vec![];
    // split into slices
    let mut size = orig.len() / NUMTHREADS;
    if orig.len() % NUMTHREADS > 0 {
        size += 1;
    }
    // if orig.len() == 0, we need another adjustment
    size = std::cmp::max(1, size);
    for chunk in orig.chunks(size) {
        let chunk = chunk.to_owned();
        let g = thread::spawn(move || {
            chunk.into_iter()
                .map(|elem| convert_lonlat(elem.0, elem.1))
                .collect()
        });
        guards.push(g);
    }
    let mut result: Vec<FloatTuple> = Vec::with_capacity(orig.len());
    for g in guards {
        result.extend(g.join()
            .unwrap()
            .into_iter()
            .map(|floats| {
                FloatTuple {
                    a: floats.0 as f32,
                    b: floats.1 as f32,
                }
            }));
    }
    Array::from_vec(result)
}
```
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
### This is‚Ä¶not great;
- Casting from i32 to f64
- Cloning slices into a `Vec`
- Calling `to_owned()` allocates again
- Is this an `unwrap()` I see before me?

> Actually, is there any reason for cloning at all here?  
I mean, the Array are in scope until the end of the call, and they are already unsafe, let's pass thin handles to them and avoid all those vectors (and memory allocations). 

> ‚Äì mathieum

üò≠üò≠üò≠
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
### Time for a Re-Think
The problem, in an abstract sort of way:
- We've got a sequence of values
- The **length** of the sequence isn't going to change
- The **type** of the values isn't going to change
	- I re-read the spec ‚Äì you **must** use `f64` values

**We can use mutable slices**
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
### Time for a Re-Think, II
- Some time has passed, and scoped-thread libraries exist now
- Can we be generic? Yep:
	- Accept two sequences
	- Accept a function
	- Zip the sequences, and split the result into mutable chunks
	- For each chunk, spawn a thread
		- In each thread, apply the function to a chunk of the sequence
		- Join them up again at the end

				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ### Interlude
					        I didn't realise that `chunks()` / `chunks_mut()` returned slices
					        - It took *days* to get the syntax correct
					        - I thought the docs could be clearer about this
					        - So I opened an issue
					        	- Had a reasonable conversation about doc clarity
					        	- And then I sent a PR, (which altered 2 words)
					        - And it was merged! (thanks Steve)
				    </script>
				    </section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
### Crossbeam
```rust
fn convert_vec_direct<'a, F>(ex: &'a mut [f64],
                             ny: &'a mut [f64],
                             func: F)
                             -> (&'a mut [f64], &'a mut [f64])
    where F: Fn(&f64, &f64) -> Result<(f64, f64), ()> + Send + Copy
{
    let numthreads = num_cpus::get() as usize;
    let mut size = ex.len() / numthreads;
    if ex.len() % numthreads > 0 {
        size += 1;
    }
    size = std::cmp::max(1, size);
    crossbeam::scope(|scope| {
        // chunks_mut returns chunks of "size"
        for (ex_ch, ny_ch) in ex.chunks_mut(size).zip(ny.chunks_mut(size)) {
            scope.spawn(move || {
                for (ex, ny) in ex_ch.iter_mut().zip(ny_ch.iter_mut()) {
                    match func(ex, ny) {
                        // mutate values, or assign default error values
                        Ok(res) => {
                            *ex = res.0;
                            *ny = res.1;
                        }
                        Err(_) => {
                            *ex = NAN;
                            *ny = NAN;
                        }
                    };
                }
            });
        }
    });
    (ex, ny)
}
```
					</script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
### Rayon
```rust
fn convert_vec_direct<'a, F>(ex: &'a mut [f64],
                             ny: &'a mut [f64],
                             func: F)
                             -> (&'a mut [f64], &'a mut [f64])
    where F: Fn(&f64, &f64) -> Result<(f64, f64), ()> + Send + Copy
{
    ex.par_iter_mut().zip(ny.par_iter_mut()).for_each(|p| {
        match func(p.0, p.1) {
            // mutate values, or assign default error values
            Ok(res) => {
                *p.0 = res.0;
                *p.1 = res.1;
            }
            Err(_) => {
                *p.0 = NAN;
                *p.1 = NAN;
            }
        }
    });
    (ex, ny)
}
```
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## Comparing Crossbeam and Rayon
					        [![Compare](assets/crossbeam_v_rayon.png)]()
				    </script>
				    </section>
			    </section>
				<section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ### Building Python Wheels
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## Using Rust-everywhere
- Essential if you want to support Linux, OSX, and Windows
- Straightforward to adapt your own needs, if your own needs are:
	- Run tests
	- If some condition is true, build artifacts and publish them as GitHub releases
	- It can integrate bits of `travis-cargo` if you want coverage, separate doc builds
- What I did:
	- Build Rust libs for all platforms when a tag is pushed, and publish to GH
	- Build script in my Python package pulls latest release from GH as part of my CI setup
	- Works on Travis and Appveyor
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## Difficulties and Gotchas
- `setup.py` is **THE WORST THING EVER**
- For Cython, it incorporates compiler and linker arguments
	- these are completely different for each platform
	- üò≠üò≠üò≠
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## `manylinux1`
- The official Linux build for widely-compatible Python wheels
- It's available as a docker image
- If you want a `manylinux1`-compatible dylib (and you do), you have to build using it
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## MinGWPy
- Not available for Python 3.5
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## OSX
- Lots of excellent build scripts at wheel-builders
				    </script>
				    </section>
			    </section>
				<section>
					<section data-markdown>
				    <script type="text/template">
					### Benchmarking `convertbng`
					- Generate 10m random WGS84 points within the GLA boundary <!-- .element: class="fragment" data-fragment-index="1" -->
					- Convert them to OSGB36 <!-- .element: class="fragment" data-fragment-index="2" -->
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
					### Benchmarking `convertbng`
					Methodology
					- 4 Amazon EC2 C4 (compute-optimised) systems were tested
					- The system was calibrated by taking the mean of 5 calibration runs of 1m random numbers
					- An identical benchmark program was then run for each of the 3 configurations
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
	## Results
| EC2 Instance Type    | Processors (vCPU) | Rust Ctypes (s) | Rust Cython (s) | Pyproj (s) | Ctypes vs Pyproj | Cython vs Pyproj |
|:----------|:----------:|:----------:|:----------:|:----------:|:----------:|----------:|
| c4.xlarge            | 4                 | 14.782          | 11.714          |  9.379     |   58.36%         |   24.97%         |
| c4.2xlarge           | 8                 | 8.647           | 6.421           |  9.256     |  -6.57%          |  -30.62%         |
| c4.4xlarge           | 16                | 6.470           | 3.716           |  9.398     |  -31.49%         |  -60.25%         |
| c4.8xlarge           | 36                | 4.913           | 2.501           |  9.308     |  -48.05%         |  -73.35%         |

					</script>
					</section>
				</section>
				<section data-markdown>
			    <script type="text/template">
				### What next for Geospatial Computing using Rust?
				- Geo-rust exists
				- Under active development
					- Aims to provide a subset of geospatial primitives (think GEOS), in the first instance
						- Point, LineString, Polygon types, and their Multi‚Äì versions
						- Distance calculation algorithms, and predicates (`contains` etc.)
						- Geometry simplification (RDP)
				- Related libraries (GeoJSON, WKT, GPX, Geohash, Shapefile, Polyline) are all stable / under active development
				- There aren't enough of us
				</script>
				</section>
				<section data-markdown>
			    <script type="text/template">
				## Thanks! Questions?
				- Me: @urschrei on Twitter
				- Rust: http://rust-lang.org
				- `convertbng`: https://github.com/convertbng
				- `lonlat_bng`: https://github.com/lonlat_bng
				- Rust-geo: https://github.com/georust/rust-geo
				</script>
				</section>
			</div>
		</div>
		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
				center: true,
				transition: 'convex',
			    math: {
			        mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
			        config: 'TeX-AMS-MML_HTMLorMML'  // See http://docs.mathjax.org/en/latest/config-files.html
			    },

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/math/math.js', async: true },
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
