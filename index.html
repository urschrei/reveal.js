<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<meta name="description" content="An introduction to geospatial computing using Rust" />
        <meta name="author" content="Stephan H√ºgel" />
		<title>Glue</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/solarized-dark.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- <section>Slide 1</section> -->
				<!-- <section>Slide 2</section> -->
				<section data-markdown>
			    <script type="text/template">
				        ## Exploiting Ousterhout's Dichotomy for fast, convenient geocomputation

				        <!-- A paragraph with some text and a [link](http://hakim.se). -->
				        Stephan H√ºgel, UCL CASA
				    </script>
				</section>
				<section data-markdown>
			    <script type="text/template">
				        ## About Me
				        - 4th year PhD student (I should be writing)
				        - I mostly work on smart cities ‚Äì history, policy, future
				        - Data analysis as productive procrastination
				        - I like to measure things, and make them go fast

				</script>
				</section>
				<!-- vertical example slides -->
				<section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
					## Routing Engines
					[![Routing](https://github.com/urschrei/router_comparison/raw/master/combined_gh.png)]()
					</script>
					</section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
					## Data Interpolation
					[![Gridding](https://github.com/urschrei/Geopython/raw/master/data/rainfall_interpolation.gif)]()
					</script>
					</section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
					## Data Viz
					[![Transforms](assets/isochrone.png)]()
					</script>
					</section>
				</section>
				<section data-markdown>
			    <script type="text/template">
				## How we do Geocomputation Now
				- In a REPL
					- RStudio
					- IPython (Jupyter)
					- Maybe Julia, eventually
				
				(this is how almost everyone in academia now does data analysis)

				(thanks Matlab)
				</script>
				</section>
				<section data-markdown data-state='noborder'>
			    <script type="text/template">
				## It's really, really good:
				- Programs can be written as fragments
				- Notebooks are easy to share
				- Everything is Open Source
				- Nobody has to write FORTRAN anymore (‚Ä¶)
				[![Transforms](assets/fortran.jpg)]()
				</script>
				</section>
				<section data-markdown>
			    <script type="text/template">
				## In Short:
				## üéâ	
				</script>
				</section>
				<section data-markdown data-state='noborder'>
			    <script type="text/template">
				## But All is not well in the Magic Kingdom
				[![Transforms](assets/ice_king.png)]() <!-- .element: class="fragment" data-fragment-index="1" -->
				</script>
				</section>
				<section data-markdown>
			    <script type="text/template">
				## Interpreted Languages are Slow
				## üê¢
				</script>
				</section>
				<section data-markdown>
			    <script type="text/template">
				## How slow?
				Difficult to measure accurately.

				In general, 1 ‚Äì 2 orders of magnitude slower than `C`.
				</script>
				</section>
				<section data-markdown>
			    <script type="text/template">
				## Does this Matter?
				It depends!

				If it takes 2s to load your data, a 100x improvement is‚Ä¶irrelevant
				</script>
				</section>
				<section data-markdown>
			    <script type="text/template">
				## But What about Big Data
				(disclaimer: I do not know what Big Data are)

				My working definition:
				- You can't process them on a single machine
				- Need tools like Hadoop / Apache Spark
				- Not going to talk about Big Data, really
				</script>
				</section>
				<section data-markdown>
			    <script type="text/template">
				## Focus on "Medium" Data Instead

				Let's flippantly define it along some axes:
				- It takes "a while" to download (a while: 1 x ‚òïÔ∏è) <!-- .element: class="fragment" data-fragment-index="1" -->
				- It takes up "a lot" of room (> 1GB, let's say) <!-- .element: class="fragment" data-fragment-index="2" -->
				- Processing it doesn't feel "instant" <!-- .element: class="fragment" data-fragment-index="3" -->

				(NB: these axes are not orthogonal) <!-- .element: class="fragment" data-fragment-index="4" -->
				</script>
				</section>
				<section data-markdown data-background-image="assets/landsat.jpg">
			    <script type="text/template">
				## Geodata Have a Tendency to be Medium
				- Satellite imagery <!-- .element: class="fragment highlight-blue" data-fragment-index="1" -->
				- Shapefiles <!-- .element: class="fragment highlight-blue" data-fragment-index="2" -->
				- GeoJSON (the most convenient, least compact data format ever) <!-- .element: class="fragment highlight-blue" data-fragment-index="3" -->
				- Waiting times can mount, especially when performing exploratory data analysis <!-- .element: class="fragment highlight-blue" data-fragment-index="4" -->
				</script>
				</section>
				<section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
					## How Can This be Mitigated?
					‚ú®Ousterhout's Dichotomy‚ú® <!-- .element: class="fragment" data-fragment-index="1" -->

					[![Gridding](http://web.stanford.edu/~ouster/cgi-bin/Photo2008Small.jpg)]() <!-- .element: class="fragment" data-fragment-index="2" -->
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
					## What on Earth‚Ä¶?
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
					## Ousterhout's dichotomy
					There are two kinds of programming languages:
					- Systems programming languages <!-- .element: class="fragment" data-fragment-index="1" -->
						- Statically Typed
						- Support complex data structures
						- Allow precise control over memory layout
						- Compiled 
					- Scripting, or "glue" languages <!-- .element: class="fragment" data-fragment-index="2" -->
						- Dynamically Typed
						- Little Provision for complex data structures
						- Programs are interpreted
					- The two interact via FFI (foreign function interface) <!-- .element: class="fragment" data-fragment-index="3" -->
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
					## Ousterhout's dichotomy
					(The stuff about data structures is no longer true. Ignore it.)
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
					## Ousterhout's dichotomy
					Some Examples:
					- Systems programming languages <!-- .element: class="fragment" data-fragment-index="1" -->
						- C
						- C++
						- FORTRAN
					- Scripting, or "glue" languages <!-- .element: class="fragment" data-fragment-index="2" -->
						- Python
						- Ruby
						- R
						- Javascript (yes, you *can* use JS for geocomputation)
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
					## Ousterhout's dichotomy
					This distinction is‚Ä¶imperfect at best. Consider:
					- Java
					- Lisp
					- Other JVM languages (Clojure, Haskell)

					‚Ä¶But it's still useful.
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
					## Ousterhout's dichotomy
					Another (crucial) distinction:

					Systems programming is really, really hard.<!-- .element: class="fragment" data-fragment-index="1" -->

					- Static typing reduces up-front flexibility <!-- .element: class="fragment" data-fragment-index="2" -->
					- Reasoning about pointers is difficult <!-- .element: class="fragment" data-fragment-index="3" -->
						- But largely unavoidable in non-GC languages; that's how memory works `¬Ø\_(„ÉÑ)_/¬Ø`
					- Toolchains are complex and arcane <!-- .element: class="fragment" data-fragment-index="4" -->
						- (compilers, linkers, `make`, `autotools`)
					- Languages are vast and/or arcane <!-- .element: class="fragment" data-fragment-index="5" -->
						- Java: ant, maven, gradle, ivy, JVM
						- C++: Boost, templates
						- C: Everyone is bad at writing C
					</script>
					</section>
					<section data-markdown>
					<script type="text/template">
					## So, so hard
					- It's easy to do things whose effects cannot be reasoned about <!-- .element: class="fragment" data-fragment-index="1" -->
						- Undefined Behaviour in C <!-- .element: class="fragment" data-fragment-index="2" -->
						- Null pointer references, AKA "The Billion-Dollar Mistake" <!-- .element: class="fragment" data-fragment-index="3" -->
						- Double-freeing memory <!-- .element: class="fragment" data-fragment-index="4" -->
					- Language semantics are intimidating to beginning / casual programmers <!-- .element: class="fragment" data-fragment-index="5" -->
	                </script>
					</section>
				</section>
				<section data-markdown>
				<script type="text/template">
				## Can We Do Better?
				Yes. Yes we can.
                </script>
				</section>
				<section>
					<section data-markdown data-state='noborder'>
					<script type="text/template">
					## Introducing Rust
					A safe, concurrent, practical language. <!-- .element: class="fragment" data-fragment-index="1" -->

					[![Rust](assets/rust.png)]() <!-- .element: class="fragment" data-fragment-index="2" -->

					https://www.rust-lang.org/en-US/
	                </script>
					</section>
					<section data-markdown data-state='noborder'>
					<script type="text/template">
					## What is Rust
					- Fast (LLVM backend, runs as fast as C++) <!-- .element: class="fragment" data-fragment-index="1" -->
					- Has modern language semantics, with zero runtime cost <!-- .element: class="fragment" data-fragment-index="2" -->
						- Iteration <!-- .element: class="fragment" data-fragment-index="3" -->
						- Type inference <!-- .element: class="fragment" data-fragment-index="4" -->
						- Pattern matching <!-- .element: class="fragment" data-fragment-index="5" -->
						- Algebraic Data Types <!-- .element: class="fragment" data-fragment-index="6" -->
						- **Memory safety** <!-- .element: class="fragment" data-fragment-index="7" -->
						- **Efficient C bindings** <!-- .element: class="fragment" data-fragment-index="8" -->
	                </script>
					</section>
					<section data-markdown>
					<script type="text/template">
					What does any of that mean???

					- Writing Rust often feels like writing Python / Ruby, due to familiar semantics <!-- .element: class="fragment" data-fragment-index="1" -->
					- Rust goes to great lengths to make your code safe <!-- .element: class="fragment" data-fragment-index="2" -->
						- Data races *cannot* exist in safe Rust (race conditions can, though)
					- ADTs make it easy to express state machines and L-systems <!-- .element: class="fragment" data-fragment-index="3" -->
					- Despite this, it's really, really fast: <!-- .element: class="fragment" data-fragment-index="4" -->
						- Rust is *not* garbage-collected‚Ä¶
							- But you don't have manage memory yourself‚Ä¶because
	                </script>
					</section>
					<section data-markdown>
					<script type="text/template">
					- An ownership system keeps tracks of resources, and drops them automatically when they go out of scope
					- Move semantics ensure that values are owned by a single reference, but can be borrowed by several

					These things are statically checked at compile time; there's no run-time overhead
	                </script>
					</section>
					<section data-markdown>
					<script type="text/template">
					## Is Everything Great?
					No!
					- The ownership system initially feels unfamiliar to‚Ä¶everyone
					- "Fighting with the borrow checker" takes up a lot of your time at first
					- The lack of a `NULL` type or `None` value can take some getting used to
						- Rust has `Result` and `Option` types instead
							- A `Result` holds either a value or an associated error
							- an `Option` can be `Some(value)` or `None()`
	                </script>
					</section>
					<section data-markdown>
					<script type="text/template">
					This is still a *vast* improvement.
					- Rust has a single tool ‚Äì `Cargo` ‚Äì which manages builds, tests, and packages
						- A Package is pretty much analogous to a Python / R package, or a Ruby Gem
					- Rust's emphasis on correctness, and its highly expressive type system result in what's termed "fearless concurrency"
					- Mutable shared access to data structures is neither difficult to implement, understand, or prone to error
						- One example: Several threads all modifying values in a vector or array
	                </script>
					</section>
					<section data-markdown>
					<script type="text/template">
					## Rust's Most Innovative Feature
					Community
					- Inclusivity is an explicit goal of the Rust project
					- Beginners are encouraged and supported
					- Development is carried out in the open
					- Decisions about the language are transparent

					Systems programming isn't usually like this
	                </script>
					</section>
				</section>
				<section>
					<section data-markdown>
					<script type="text/template" class="nopad">
## What does Rust look like?
```Rust
fn square(elem: &i32) -> i32 {
    elem.pow(2)
}

fn main() {
    let v: Vec<i32> = vec![1, 2, 3];
    let squared: Vec<i32> = v.iter().map(|elem| {
    	square(elem)
    }).collect();
}
```
					</script>
					</section>
					<section data-markdown>
					<script type="text/template" class="nopad">
## What does Rust look like?
```Rust
// Used to match against a zero or non-zero remainder
enum Rem {
    // No remainder
    Zero,
    // A remainder between 1 and 4
    Other(NonZeroRem),
}

// Used to match a non-zero remainder
enum NonZeroRem {
    One,
    Two,
    Three,
    Four,
}

// Easily allows us to exhaustively decide the return value
// Input is the remainder of a modulo operation from a match expression
fn int_to_rem(num: u8) -> Rem {
    match num {
        0 => Rem::Zero,
        1 => Rem::Other(NonZeroRem::One),
        2 => Rem::Other(NonZeroRem::Two),
        3 => Rem::Other(NonZeroRem::Three),
        4 => Rem::Other(NonZeroRem::Four),
        _ => panic!("oops"),
    }
}

fn main() {
    for num in (1..101).collect::<Vec<u8>>() {
        println!("{}",
                 match (int_to_rem(num % 3), int_to_rem(num % 5)) {
                     (Rem::Zero, Rem::Zero) => "FizzBuzz".to_string(),
                     (Rem::Zero, Rem::Other(_)) => "Fizz".to_string(),
                     (Rem::Other(_), Rem::Zero) => "Buzz".to_string(),
                     (Rem::Other(_), Rem::Other(_)) => num.to_string(),
                 })
    }
}
```
					</script>
					</section>
					<section data-markdown id="crossbeam">
					<script type="text/template" class="nopad">
## What does Rust look like?
```Rust
// func is a conversion function which accepts two f64 inputs
fn convert_vec_direct<'a, F>(ex: &'a mut [f64],
                             ny: &'a mut [f64],
                             func: F)
                             -> (&'a mut [f64], &'a mut [f64])
    where F: Fn(&f64, &f64) -> Result<(f64, f64), ()>+Send+Copy+Sync
{
    let numthreads = num_cpus::get() as usize;
    let mut sz = ex.len() / numthreads;
    if ex.len() % numthreads > 0 {
        sz += 1;
    }
    sz = std::cmp::max(1, sz);
	crossbeam::scope(|scope| {
	    // chunks_mut returns chunks of "sz"
	    // e.g. 20 items / 4 (numthreads) = 5, resulting in 4 chunks
	    for (ex_ch, ny_ch) in ex.chunks_mut(sz).zip(ny.chunks_mut(sz)) {
	        scope.spawn(move || {
	            for (ex, ny) in ex_ch.iter_mut().zip(ny_ch.iter_mut()) {
	                match func(ex, ny) {
	                    // mutate values, or assign default error values
	                    Ok(res) => {
	                        *ex = res.0;
	                        *ny = res.1;
	                    }
	                    Err(_) => {
	                        *ex = NAN;
	                        *ny = NAN;
	                    }
	                };
	            }
	        });
	    }
	});
}
```
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
					## How to write Rust
					1. go to `rustup.rs` and follow the 1-line installation instructions
					2. In a terminal, type `cargo init myproject && cd myproject`
					3. open `src/lib.rs` in your editor of choice
					4. write some code, and a test (a skeleton is provided for you)
					5. Switch to your terminal, and run `cargo test`
					6. If your test passes, run `cargo build --release`
					7. You now have an optimised dynamic library!
					</script>
					</section>
				</section>
				<section>
					<section data-markdown>
				    <script type="text/template">
					## Rust in the Real World
					### Implementing the OSTN02 transform

					OSTN02: a high-precision conversion from geographic WGS84 coordinates to projected OSGB36 coordinates

					1. 7-step Helmert Transform (WGS84 Lon, Lat ‚û°Ô∏è ETRS89 Eastings and Northings)
					2. Retrieval of physically-measured correction parameters within a kilometer grid
					3. Linear interpolation to determine precise corrections to apply
					4. Addition of these produces the shift from the GRS80 to the Airy 1830 Ellipsoid

					Step 2 is the slowest part of the process.
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
					## Why OSTN02
					- It's extremely well defined (thanks, Ordnance Survey!) <!-- .element: class="fragment" data-fragment-index="1" -->
						- Detailed worked examples
						- Test data is supplied
					- It presents an interesting problem <!-- .element: class="fragment" data-fragment-index="2" -->
						- How to store the surveyed corrections
						- How to quickly retrieve them	
					- Fundamental limit to the speed of some of the steps <!-- .element: class="fragment" data-fragment-index="3" -->
						- The initial Helmert transform can only be made so fast
						- Once a fast method has been found for retrieving the corrections, there's no more low-hanging fruit
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
					## What else could we do?
					- Point transformations are calculated independently of one another <!-- .element: class="fragment" data-fragment-index="1" -->
					- So, for a list (or vector, or array) of points, a multi-threading approach is ideal<!-- .element: class="fragment" data-fragment-index="2" -->
					- it's embarassingly parallel <!-- .element: class="fragment" data-fragment-index="2" -->
					- Rust is really, really good at this<!-- .element: class="fragment" data-fragment-index="3" -->
						- It's easy to implement, and it's guaranteed to be memory-safe
						- [It looks like this](index.html#/crossbeam)
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
					## Rust in the Real World
					<!-- .element: class="fragment" data-fragment-index="1" -->Introducing `lonlat_bng` and `convertbng` 
					
					<!-- .element: class="fragment" data-fragment-index="2" -->`lonlat_bng`: a Rust library implementing the OS OSTN02 transform 
					
					<!-- .element: class="fragment" data-fragment-index="3" -->`convertbng`: a Python package powered by `lonlat_bng`, available on OSX, Windows, and Linux, for Python 2.7, 3.5, and 3.5

					`lonlat_bng` source: https://github.com/urschrei/lonlat_bng
					`convertbng` source: https://github.com/urschrei/convertbng 
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
					## Rust in the Real World
					- Installing `convertbng`
						1. `pip install convertbng`
						2. There is no step 2
					- Using `lonlat_bng`
						1. Get the dylib for your platform from https://github.com/urschrei/lonlat_bng/releases
						2. Write some FFI glue code in your preferred language
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
					## Benchmarking `convertbng`
					- Generate 10m random WGS84 points within the GLA boundary <!-- .element: class="fragment" data-fragment-index="1" -->
					- Convert them to OSGB36 <!-- .element: class="fragment" data-fragment-index="2" -->
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
					## Benchmarking `convertbng`
					Methodology
					- 4 Amazon EC2 C4 (compute-optimised) systems were tested
					- The system was calibrated by taking the mean of 5 calibration runs of 1m random numbers
					- An identical benchmark program was then run for each of the 3 configurations
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
	## Results
	| EC2 Instance Type    | Processors (vCPU) | Rust Ctypes (s) | Rust Cython (s) | Pyproj (s) | Ctypes vs Pyproj | Cython vs Pyproj |
	|:---------------------|:-----------------:|:---------------:|:---------------:|:----------:|:----------------:|-----------------:|
	| c4.xlarge            | 4                 | 23.075          | 21.964          |  18.73     |   23.39%         |  17.45%          |
	| c4.2xlarge           | 8                 | 13.35           | 11.160          |  19.055    |  -29.93%         |  -41.43%         |
	| c4.4xlarge           | 16                | 8.73            | 6.117           |  18.797    |  -53.55%         |  -67.45%         |
	| c4.8xlarge           | 36                | 6.016           | 3.667           |  17.883    |  -66.35%         |  -79.49%         |
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
					## Benchmarks
					On a 36-processor machine, we can convert 10m points with better-than-millimeter accuracy, in **70ms**

					Pyproj can convert the same points in **300ms**, and with only 5 metre accuracy.

					Of course, Pyproj (and underlying it, PROJ.4) is single-threaded, and `convertbng` is multi-threaded

					Which‚Ä¶is sort of my point:

					Adding **safe**, concurrently-mutable multi-threading was around 30 lines of code.
					</script>
					</section>
				</section>
				<section data-markdown>
			    <script type="text/template">
				## What next for Geospatial Computing using Rust?
				- Geo-rust exists
				- Under active development
					- Aims to provide a subset of geospatial primitives (think GEOS), in the first instance
						- Point, LineString, Polygon types, and their Multi‚Äì versions
						- Distance calculation algorithms, and predicates (`contains` etc.)
						- Geometry simplification (RDP)
				- Related libraries (GeoJSON, WKT, GPX, Geohash, Shapefile, Polyline) are all stable / under active development
				- There aren't enough of us
				</script>
				</section>
				<section data-markdown>
			    <script type="text/template">
				## Thanks! Questions?
				- Me: @urschrei on Twitter
				- Rust: http://rust-lang.org
				- `convertbng`: https://github.com/convertbng
				- `lonlat_bng`: https://github.com/lonlat_bng
				- Rust-geo: https://github.com/georust/rust-geo
				- Landsat 8 image ¬© Charlie Loyd: https://www.flickr.com/photos/vruba/28549179875/
				- **ADVENTURE TIME** and all related characters and elements are trademarks of and ¬© Cartoon Network
				</script>
				</section>
			</div>
		</div>
		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
				center: true,
				transition: 'convex',

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
