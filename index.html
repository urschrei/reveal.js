<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<meta name="description" content="An introduction to geospatial computing using Rust" />
        <meta name="author" content="Stephan H√ºgel" />
		<title>Coordinate System</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">
		<link rel="stylesheet" href="css/custom.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/solarized-dark.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- <section>Slide 1</section> -->
				<!-- <section>Slide 2</section> -->
				<section data-markdown>
			    <script type="text/template">
				        ## Teaching Myself Rust via the medium of Coordinate System Transforms
				        Stephan H√ºgel, UCL CASA
				    </script>
				</section>
				<section data-markdown>
			    <script type="text/template">
				        ## About Me
				        - 4th year PhD student (I should be writing)
				        	- English degree
				        	- Master's in DH
				        - I mostly work on smart cities ‚Äì history, policy, future
				        - Programming is not my job
					        - I do data analysis and visualisation as productive procrastination
					        - Mostly work in Python (Pandas, NumPy, Matplotlib, Basemap)
					        - I use a lot of maps of parts of the UK
				</script>
				</section>
				<!-- vertical example slides -->
				<section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
					## Data Analysis
					[![Routing](https://github.com/urschrei/router_comparison/raw/master/combined_gh.png)]()
					</script>
					</section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
					## Spatial Analysis
					[![Gridding](https://github.com/urschrei/Geopython/raw/master/data/rainfall_interpolation.gif)]()
					</script>
					</section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
					## Data Viz
					[![Transforms](assets/isochrone.png)]()
					</script>
					</section>
				</section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
					## Why Rust?
					- A series of weird coincidences
					- A need to convert large numbers of coordinates
					</script>
					</section>


				<section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## What is a coordinate system (CRS)
					        - A way of describing locations on earth
					        - Two components: the *datum*, and the *coordinate system*

					        - **Datum**: describes how the CRS is related to the earth
					        	- Position of the origin
					        	- Scale
					        	- **Surface**
					        	- **Geoid**

					        - **Coordinate system**: describes how the coordinates are expressed
					        	- Cartesian (x, y, z)
					        	- Ellipsoidal ($\lambda, \mu, \nu$)
					        	- Projected coordinates (UTM: 13.38891¬∫ E, 52.51690¬∫ N)
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## WGS 84 
					        - US-led, but now a global system
					        - Datum specifies an origin at the centre of the earth
					        - Uses the WGS 84 ellipsoid
					        - Position within WGS 84 is determined using GPS
					        - Designed to be globally consistent ¬±1m
					        - ETRS89 is a high-accuracy "realisation" of WGS 84, used for surveying
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
					Of course, the UK has no interest in these fripperies
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
## The "National Grid"
- Used on UK maps
- Also used in Shape Files
- Based on OSGB36 datum
- Uses an ellipsoid known as **Airy 1830** üí®
	- (It's actually named after Sir George Biddell Airy KCB PRS)
    - It's a better fit for Britain than WGS 84, because it fits the local sea level more accurately üåä
- On maps, it uses Easting and Northing coordinates
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
## Transforming Between Coordinate Systems
### The Helmert Transform
Datums can differ in three ways:

1. Position of the origin of coordinates
2. Orientation of the coordinate axes (and hence of the reference ellipsoid)
3. Size and shape of the reference ellipsoid
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
## Transforming Between Coordinate Systems
- If you work in 3D cartesian coordinates, you don't have to worry about (3)
- It's straightforward to carry out this conversion
- Just trust me on this
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
## Transforming Between Coordinate Systems
We use six parameters to describe the difference between two datums:
- Three parameters to describe a 3D translation between the coordinate origins
- Three parameters to describe a 3D rotation between the orientations of the coordinate axes.

This can be expressed as a linear formula which assumes that the rotation parameters are ‚Äòsmall‚Äô
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
## omgmatrices
$
\begin{bmatrix}
    x\\\
    y\\\
    z\\\
\end{bmatrix}^B
=
\begin{bmatrix}
    t_X\\\
    t_Y\\\
    t_Z\\\
\end{bmatrix}
+
\begin{bmatrix}
    1+s  & -r_Z & r_Y\\\
    r_Z  & 1+s  & -r_X\\\
    -r_Y & r_X  & 1+s\\\
\end{bmatrix}
\cdot
\begin{bmatrix}
    x\\\
    y\\\
    z\\\
\end{bmatrix}^A
$
Where:
- $t_X$ ,$t_Y$ and $t_Z$ are the translations along the X, Y and Z axes respectively in metres,
- $r_X$ , $r_Y$ and $r_Z$ are the rotations about the X, Y and Z axes respectively in radians
- $s$ is the scale factor (unitless) minus one.

(there are no more mathematical formul√¶ in this talk, fyi)
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## So we're done here?
					        Well, no.
					        ‚Ä¶the Helmert transform introduces horizontal error up to 3m.  
					        (we're not really worried about height)  

					        This is OK, but no use for accurate applications like surveying.
					        These demand transformations accurate to around 0.1m
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
## UK Ordnance Survey Has Got This
### The OSTN02‚Ñ¢ and OSTN15‚Ñ¢ transforms
- "Rubber-sheet" transforms
- Use a file of grid shift parameters with 1km resolution
- Bilinear interpolation to get precise adjustments
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
						## Implementing the OSTN02‚Ñ¢ / OSTN15‚Ñ¢ transform

						1. 7-step Helmert Transform (WGS84 Lon, Lat ‚û°Ô∏è ETRS89 Eastings and Northings)
						2. Retrieval of precisely-calculated parameters within a kilometer grid
						3. Bilinear interpolation to determine precise corrections to apply
						4. Addition of these produces the shift from the GRS80 to the Airy 1830 Ellipsoid
				    </script>
				    </section>
			    </section>
			    <section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
				        ## Implementing the transform ‚Äì first steps
				        Not going to go into much detail, because it's quite boring?
				        `conversions.rs`, L284‚Äì373
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
### Integrating the adjustments
There's just one problem: there are 876,951 adjustments.  
Each adjustment is a set of three floating-point values.  
They're in a SQLite DB  
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
## PHF
- A compile-time static map
- Get all the records using `rusqlite`
- Copy and adapt the `PHF` example
	- Key is an `i32`, value is `(f64, f64, f64)`
- It takes a long time to build
- It also takes a long time to compile
	- Split it into a separate crate, add it to `Cargo.toml`
	- Never worry about it again
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
## First Attempt at Threading
```rust
#[no_mangle]
pub extern "C" fn convert_thr(eastings: Array, northings: Array) -> Array {
    // we're receiving floats
    let lon = unsafe { eastings.as_i32_slice() };
    let lat = unsafe { northings.as_i32_slice() };
    // copy values and combine
    let orig: Vec<(i32, i32)> = lon.iter()
        .cloned()
        .zip(lat.iter()
            .cloned())
        .collect();

    let mut guards: Vec<JoinHandle<Vec<(f64, f64)>>> = vec![];
    // split into slices
    let mut size = orig.len() / NUMTHREADS;
    if orig.len() % NUMTHREADS > 0 {
        size += 1;
    }
    // if orig.len() == 0, we need another adjustment
    size = std::cmp::max(1, size);
    for chunk in orig.chunks(size) {
        let chunk = chunk.to_owned();
        let g = thread::spawn(move || {
            chunk.into_iter()
                .map(|elem| convert_lonlat(elem.0, elem.1))
                .collect()
        });
        guards.push(g);
    }
    let mut result: Vec<FloatTuple> = Vec::with_capacity(orig.len());
    for g in guards {
        result.extend(g.join()
            .unwrap()
            .into_iter()
            .map(|floats| {
                FloatTuple {
                    a: floats.0 as f32,
                    b: floats.1 as f32,
                }
            }));
    }
    Array::from_vec(result)
}
```
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
This is‚Ä¶not great;
- Cloning slices into a `Vec`
- Calling `to_owned()` allocates again
- Is this an `unwrap()` I see before me?

üò≠üò≠üò≠
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
## Time for a Re-Think
The problem, in an abstract sort of way:
- We've got a sequence of values
- The **length** of the sequence isn't going to change
- The **type** of the values isn't going to change

**We can use mutable slices**
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
## Time for a Re-Think, II
- Some time has passed, and scoped-thread libraries exist now
- Can we be generic? Yep:
	- Accept two sequences
	- Accept a function
	- Zip the sequences, and split the result into mutable chunks
	- For each chunk, spawn a thread
		- In each thread, apply the function to a chunk of the sequence
		- Join them up again at the end

üçæ

				    </script>
				    </section>
					<section data-markdown data-state='noborder'>
				    <script type="text/template">
## Crossbeam
```rust
fn convert_vec_direct<'a, F>(ex: &'a mut [f64],
                             ny: &'a mut [f64],
                             func: F)
                             -> (&'a mut [f64], &'a mut [f64])
    where F: Fn(&f64, &f64) -> Result<(f64, f64), ()> + Send + Copy
{
    let numthreads = num_cpus::get() as usize;
    let mut size = ex.len() / numthreads;
    if ex.len() % numthreads > 0 {
        size += 1;
    }
    size = std::cmp::max(1, size);
    crossbeam::scope(|scope| {
        // chunks_mut returns chunks of "size"
        for (ex_ch, ny_ch) in ex.chunks_mut(size).zip(ny.chunks_mut(size)) {
            scope.spawn(move || {
                for (ex, ny) in ex_ch.iter_mut().zip(ny_ch.iter_mut()) {
                    match func(ex, ny) {
                        // mutate values, or assign default error values
                        Ok(res) => {
                            *ex = res.0;
                            *ny = res.1;
                        }
                        Err(_) => {
                            *ex = NAN;
                            *ny = NAN;
                        }
                    };
                }
            });
        }
    });
    (ex, ny)
}
```
					</script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
## Rayon
```rust
fn convert_vec_direct<'a, F>(ex: &'a mut [f64],
                             ny: &'a mut [f64],
                             func: F)
                             -> (&'a mut [f64], &'a mut [f64])
    where F: Fn(&f64, &f64) -> Result<(f64, f64), ()> + Send + Copy
{
    ex.par_iter_mut().zip(ny.par_iter_mut()).for_each(|p| {
        match func(p.0, p.1) {
            // mutate values, or assign default error values
            Ok(res) => {
                *p.0 = res.0;
                *p.1 = res.1;
            }
            Err(_) => {
                *p.0 = NAN;
                *p.1 = NAN;
            }
        }
    });
    (ex, ny)
}
```
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## Comparing Crossbeam and Rayon
					        [![Compare](assets/crossbeam_v_rayon.png)]()
				    </script>
				    </section>
			    </section>
				<section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## Building Python Wheels
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## What is `rpath`?!
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## Using Rust-everywhere
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## Difficulties and Gotchas
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## `manylinux1`
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## MinGWPy
				    </script>
				    </section>
				    <section data-markdown data-state='noborder'>
				    <script type="text/template">
					        ## OSX
				    </script>
				    </section>
			    </section>
				<section>
					<section data-markdown>
				    <script type="text/template">
					## Benchmarking `convertbng`
					- Generate 10m random WGS84 points within the GLA boundary <!-- .element: class="fragment" data-fragment-index="1" -->
					- Convert them to OSGB36 <!-- .element: class="fragment" data-fragment-index="2" -->
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
					## Benchmarking `convertbng`
					Methodology
					- 4 Amazon EC2 C4 (compute-optimised) systems were tested
					- The system was calibrated by taking the mean of 5 calibration runs of 1m random numbers
					- An identical benchmark program was then run for each of the 3 configurations
					</script>
					</section>
					<section data-markdown>
				    <script type="text/template">
	## Results
| EC2 Instance Type    | Processors (vCPU) | Rust Ctypes (s) | Rust Cython (s) | Pyproj (s) | Ctypes vs Pyproj | Cython vs Pyproj |
|:----------|:----------:|:----------:|:----------:|:----------:|:----------:|----------:|
| c4.xlarge            | 4                 | 14.432          | 12.114          |  18.358    |  -21.38%         |  -34.01%         |
| c4.2xlarge           | 8                 | 8.699           | 6.417           |  18.03     |  -52.46%         |  -64.97%         |
| c4.4xlarge           | 16                | 6.470           | 3.716           |  18.561    |  -65.14%         |  -79.97%         |
| c4.8xlarge           | 36                | 4.913           | 2.501           |  17.965    |  -72.652%        |  -86.07%         |

					</script>
					</section>
				</section>
				<section data-markdown>
			    <script type="text/template">
				## What next for Geospatial Computing using Rust?
				- Geo-rust exists
				- Under active development
					- Aims to provide a subset of geospatial primitives (think GEOS), in the first instance
						- Point, LineString, Polygon types, and their Multi‚Äì versions
						- Distance calculation algorithms, and predicates (`contains` etc.)
						- Geometry simplification (RDP)
				- Related libraries (GeoJSON, WKT, GPX, Geohash, Shapefile, Polyline) are all stable / under active development
				- There aren't enough of us
				</script>
				</section>
				<section data-markdown>
			    <script type="text/template">
				## Thanks! Questions?
				- Me: @urschrei on Twitter
				- Rust: http://rust-lang.org
				- `convertbng`: https://github.com/convertbng
				- `lonlat_bng`: https://github.com/lonlat_bng
				- Rust-geo: https://github.com/georust/rust-geo
				</script>
				</section>
			</div>
		</div>
		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
				center: true,
				transition: 'convex',
			    math: {
			        mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
			        config: 'TeX-AMS-MML_HTMLorMML'  // See http://docs.mathjax.org/en/latest/config-files.html
			    },

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/math/math.js', async: true },
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
